# -*- coding: utf-8 -*-
"""BigQuery bquxjob_6c2d983b_18b853ec013

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/notebooks/bigquery_job.ipynb
"""

# @title Setup
from google.colab import auth
from google.cloud import bigquery
from google.colab import data_table

project = 'playpen-b0615f' # Project ID inserted based on the query results selected to explore
location = 'US' # Location inserted based on the query results selected to explore
client = bigquery.Client(project=project, location=location)
data_table.enable_dataframe_formatter()
auth.authenticate_user()

# Running this code will read results from your previous job

job = client.get_job('bquxjob_2c550f59_18b8b59e1a9') # Job ID inserted based on the query results selected to explore
results = job.to_dataframe()
results

"""do a load of stuff to look at shape etc

"""

df = (results)

print( df)

df.shape

df.isnull().sum()

df.dropna()

df=df.replace('',np.nan).dropna()

df.dtypes

df.limit_balance.astype(float)

df.default_payment_next_month.astype(float)

df.dtypes

"""create numpy arrays"""

age = df[['age']].to_numpy()

limit_balance = df[['limit_balance']].to_numpy()

default = df[['default_payment_next_month']].to_numpy()

default.astype(float)

scaler = MinMaxScaler(feature_range=(0,1))
scaled_limit = scaler.fit_transform((limit_balance).reshape(-1,1))

print(scaled_limit)

import numpy as np
import pandas as pd
##from random import randint
from sklearn.preprocessing import MinMaxScaler

results.describe()

# @title Default title text
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import categorical_crossentropy

model = Sequential([Dense(units=16, input_shape=(1,),activation='relu'),
                    Dense(units=32, activation='relu'),
                    Dense(units=2, activation='softmax')])

model.summary()

model.compile(optimizer=Adam(learning_rate=0.0001),loss='sparse_categorical_crossentropy', metrics=['accuracy'])

model.fit(x=scaled_limit, y=default.astype(float), validation_split=0.2, batch_size = 10, epochs=30,  verbose=2)

scaler = MinMaxScaler(feature_range=(0,1))
scaled_test_limit = scaler.fit_transform((limit_balance).reshape(-1,1))

"""Predict Outcomes"""

predictions = model.predict(scaled_test_limit, batch_size=10, verbose=0)

predictions

classes_x=np.argmax(predictions,axis=1)

print(classes_x)

"""Confusion Matrix"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from sklearn.metrics import confusion_matrix
import itertools
import matplotlib.pyplot as plt

cm = confusion_matrix(default.astype(float), classes_x.astype(float))

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j],
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

cm_plot_labels = ['Not Defaulted','Defaulted']
plot_confusion_matrix(cm, cm_plot_labels, title='Confusion Matrix')
